%%%%%%%%%%%%%%% Updated by MR March 2007 %%%%%%%%%%%%%%%%
\documentclass[12pt]{article}
\usepackage{a4wide}

\newcommand{\al}{$<$}
\newcommand{\ar}{$>$}

\usepackage{minted}
%\usemintedstyle{colorful}
\setmintedinline{breaklines}

\newcommand{\textinline}{\mintinline{text}}
\newcommand{\cinline}{\mintinline{C}}
\newcommand{\camlinline}{\mintinline{OCaml}}

\parindent 0pt
%\parskip 6pt

\hyphenpenalty=1000

\begin{document}
	
	\thispagestyle{empty}
	
	\rightline{\large{Paul Durbaba}}
	\medskip
	\rightline{\large{Robinson}}
	\medskip
	\rightline{\large{pd452}}
	
	\vfil
	
	\centerline{\large Computer Science Tripos: Part II Project Proposal}
	\vspace{0.4in}
	\centerline{\Large\bf Compiling OCaml to WebAssembly}
	\vspace{0.3in}
	\centerline{\large{Friday 18\textsuperscript{th} October, 2018}}
	
	\vfil
	
	{\bf Project Originator:} Based on a proposal by Tim Jones
	
	\vspace{0.1in}
	
	{\bf Resources Required:} See attached Project Resource Form
	
	\vspace{0.5in}
	
	{\bf Project Supervisor:} Tobias Kohn
	
	\vspace{0.2in}
	
	{\bf Signature:}
	
	\vspace{0.5in}
	
	{\bf Director of Studies:}  Alan Mycroft
	
	\vspace{0.2in}
	
	{\bf Signature:}
	
	\vspace{0.5in}
	
	{\bf Overseers:} Pietro Lio' and Robert Mullins
	
	\vspace{0.2in}
	
	{\bf Signatures:} 
	
	\vfil
	\eject
	
	
	\section*{Introduction and Description of the Work}
	The aim of the project is to implement a compiler from a subset of OCaml to WebAssembly.
	\\\\
	WebAssembly\footnote{https://webassembly.org/} is a binary instruction format for the web with the main goal of improving performance of more computationally intensive functions in web applications. It does not replace JavaScript as there (currently) is no way to perform tasks such as DOM manipulation directly from WebAssembly - it is expected that a JavaScript application might call some functions implemented in WebAssembly to perform computation, and then display the results itself.
	\\\\
	My work will involve writing a compiler in OCaml and a runtime system in a language such as C. 
	\\\\
	The compiler will take an AST (abstract syntax tree) produced by the lexer and parser of the OCaml compiler\footnote{https://github.com/ocaml/ocaml} (ocaml-compiler-libs), performing type checking (I considered using the OCaml type checker, but getting that to work might be just as hard as writing my own type checker), and then transforming the typed AST through a series of intermediate representations (IRs). Each IR will eliminate some higher-level feature, for instance replacing first-class functions with closures. At the end, I will generate instructions to target WebAssembly. The WebAssembly Binary Toolkit\footnote{https://github.com/WebAssembly/wabt} will then be used to output a usable WebAssembly module.
	\\\\
	The runtime system will be needed to implement closures and memory allocation / access in a way that can be used by the code generated by my compiler.
	
	\section*{Starting Point}
	\subsection*{OCaml and Compilers}
	I have done very little programming in OCaml previously, with the exception of coming up with some code samples when considering which features this compiler should support. However I have some experience in programming in Standard ML, a similar language, from Part IA Foundations of Computer Science.
	\\\\
	I also have little previous experience in writing compilers. I have written basic lexers and parsers, and implemented a system for interpreting mathematical expressions, however I have no experience with a larger compiler that compiles to instructions instead of interpreting.
	
	\subsection*{WebAssembly and the Web}
	I have no experience with WebAssembly with the exception of reading through some of the documentation in the weeks leading up to this proposal.
	\\\\
	I have a fair amount of experience with JavaScript and websites: I do not anticipate any issue with coming up with a suitable demonstration of the WASM produced by the compiler.
	
	
	\section*{Substance and Structure of the Project}
	
	%KEY CONCEPTS, MAJOR WORK ITEMS, THEIR RELATIONS AND RELATIVE IMPORTANCE, DATA STRUCTURES AND ALGORITHMS
	
	%Key Concepts: Type Checking, WebAssembly, Runtime System, Closure
	%Major Work Items: Components
	%Relative importance: All important!
	
	%Data Structures: Trees, lots of trees!

	The main components of the compiler are the type checker, the intermediate representations, the WebAssembly code generator, and the runtime system. These will need to be implemented in the order listed, as each depends on the last, with the exception of the runtime system and code generator which can be developed in parallel, as a change in one might require a change in the other. Likewise, they are all equally important in a complete compiler, as each part is required during the translation from AST through to a WebAssembly module.
	\\\\
	My subset of OCaml will include the following:
	\begin{itemize}
		\item Values: \camlinline{int} (64-bit signed integer), \camlinline{bool} and \camlinline{float} (64-bit floating point), able to be defined using expressions \camlinline{let} and \camlinline{let ... in}.
		\item Functions: \camlinline{let} and \camlinline{let rec} with multiple curried arguments, with an expression for the function body, as well as inline functions using \camlinline{fun}
		\item Types: Non-polymorphic types defined using \camlinline{type}, and tuples. These can be used to implement list types, and hence lists themselves will not be part of the subset (although supporting list syntax will be an extension)
		\item \camlinline{if ... then ... else} and basic pattern matching. I was planning on excluding pattern matching from the initial subset, however it is needed to match types and de-structure them, and alternate approaches would lead to clumsy syntax. Pattern matching will be limited to use on types.
	\end{itemize}
	Polymorphism is excluded from the initial subset as I do know how challenging to implement it will be, however it will likely be the first stretch goal that I try and implement.

	\subsection*{Testing}
	I intend to write unit tests, for instance using the OUnit\footnote{https://github.com/gildor478/ounit} unit testing framework. These will function to demonstrate that sub-components are working before the whole compiler can be tested, and more importantly to prevent the re-introduction of bugs that have already been fixed by writing a unit test when a bug is found to ensure it doesn't occur again.
	\\\\
	The overall compiler will be tested with a selection of code samples designed to test important features and edge cases. The compiled code will be executed in the browser and the result checked against the expected result. This could also be automated, e.g. by using a WebAssembly interpreter such as the WebAssembly reference interpreter\footnote{https://github.com/WebAssembly/spec/tree/master/interpreter}, depending on the complexity of this.
	
	\subsection*{Evaluation}
	I will evaluate my compiler in comparison to other methods of executing OCaml, particularly on the web, such as the OCaml compiler and Js\_of\_ocaml\footnote{https://ocsigen.org/js\_of\_ocaml/3.1.0/manual/overview}. I will do this by measuring performance in terms of how long particular samples of OCaml code take to execute on these different platforms, by running them multiple times on each platform (or the sample includes a loop of the same effect), and recording the time between execution starting and execution completing.
	\\\\
	It would also be interesting to compare memory usage between the different approaches, however that will likely be unfeasible due to the difficulty of getting accurate memory usage statistics, e.g. how much of the browser's memory is used by the JavaScript OCaml interpreter.
	\\\\
	When optimisations are implemented, I will analyse the performance with and without the optimisation, for instance by using timing facilities available in JavaScript. An optimisation will be considered successful if it leads to a measurable increase in execution speed (or a measurable decrease in memory usage) for a carefully chosen set of OCaml programs.
	
	
	\section*{Success Criterion}
	The project will be a success if the following criteria are met:
	\begin{itemize}
		\item The compiler can take a selection of reasonable (not likely to result in more than 10MB of memory allocation) samples written using all features of the selected subset of OCaml, and compile them to WebAssembly modules
		\item These WebAssembly modules can be loaded and executed with a set of provided input values for each sample in the latest version of Chrome and Firefox to produce the same results as if the OCaml code they were compiled from was compiled, executed, and given the same input value by the OCaml Compiler
	\end{itemize}
	
	
	\section*{Possible Extensions}
	% Pattern Matching, References and Loops, Garbage Collection, Exceptions,
	\begin{itemize}
		\item Expanding my subset of OCaml supported: polymorphism, more advanced pattern matching, list syntax, strings, references, for and while loops, modules...
		
		\item Improving code access from JavaScript, for instance allowing JavaScript objects (probably just numbers and strings) to be passed to OCaml functions, likely with a special type to represent JavaScript objects
		
		\item Optimisations: There are many optimisations that could be implemented to improve the code generated by the compiler, for instance peephole optimisation, dead-code elimination, constant propagation, function call inlining, and many more that I could learn about.
		
		\item End to End testing: Using a WebAssembly interpreter, whereby I can specify a sample of programs to compile, and the expected output from running them, and validate that they all compile and produce the expected results in the interpreter.
		
		\item Supporting Exceptions. This would be challenging due to WebAssembly's current lack of support for them, however there are ways of working around this, with their own performance costs. One way might be to make functions that throw exceptions return a type that signifies either a result or an exception was thrown, then we can check if an exception was thrown after each function call, and propagate exceptions until a relevant catch block is found.
		
		\item Garbage Collection. WebAssembly likewise does not currently support garbage collection, and additionally does not allow walking the stack for security reasons. There are limited ways to work around this: by storing all values except for primitive types and references on the heap, reference counting could be used to track which heap items have references on the stack, and tracing could be used between heap items. A system like this would likely have to be implemented in JavaScript or TypeScript due to the complexity of getting it right in WebAssembly.
		
	\end{itemize}
	
	
	\section*{Timetable and Milestones}
	
	\subsection*{25th Oct - 8th Nov}
	Getting ready:
	\begin{itemize}
		\item Creating a git repository and GitHub remote for the project, and skeleton for the overall project
		\item Setting up the required libraries (the ocaml-compiler-libs)
		\item Setting up and trying out unit testing with OUnit
		\item Parsing OCaml files using the ocaml-compiler-libs parser, and experimenting with the resulting ASTs to learn more about them 
	\end{itemize}
	In addition, I will practice coding in OCaml to learn more about the language and come up with useful code samples that will be useful for testing later on. The book \textit{Types and Programming Languages} by Benjamin C. Pierce contains some OCaml samples to help me learn and also prepare me for writing the type checker.
	
	\subsection*{9th Nov - 22nd Nov}
	I will implement a type checker for the initial subset of OCaml. If I have time, polymorphism (an extension) could also be implemented at this stage, certainly my implementation of type checking will have to consider how polymorphism will be implemented in the future.
	\\\\
	At the end of this I should have a function that can take an OCaml AST and output a typed AST, with a type attached to each node.
	
	\subsection*{23nd Nov - 6 Dec}
	Implement translation of the typed AST through to a lower-level representation suitable for transformation into WebAssembly instructions.
	
	\subsection*{7 Dec - 20 Dec}
	Implement code generation and a suitable runtime system for WebAssembly to perform memory allocation and closure calls, probably using C. After this point, it should be possible to use the compiler to compile some code samples and execute them in a browser, and hence I will have met my success criterion.
	
	\subsection*{20 Dec - 3 Jan}
	I will probably be taking about a week's break from the project, and using the remaining time in these two weeks to clean up / improve the project if the success criterion has been met (for instance by refactoring, implementing additional test cases or adding better error messages), and continue working up to the success criterion otherwise.
	
	\subsection*{4 Jan - 17 Jan}
	I will implement polymorphism in the type checker and some form of polymorphism elimination in the intermediate representation. I also hope to implement references and for/while loops, which should be fairly simple to implement but will allow more interesting programs to be compiled.
	
	\subsection*{17 Jan - 31 Jan}
	I will implement some optimisations such as the ones I listed above, and evaluate them as I described in the evaluation section.
	\\\\
	Write the progress report.
	
	\subsection*{1 Feb - 14 Feb}
	Presentations and preparation needed for them.
	\\\\
	I will investigate and implement some way of passing JavaScript values (numbers and strings) to functions, and seek to improve my pattern matching implementation by compiling more complicated match statements.
	
	\subsection*{15 Feb - 28 Feb}
	I will set up an end to end testing system as described in the stretch goals section.
	
	\subsection*{1 Mar - 13 Mar}
	Start writing dissertation. Investigate supporting exceptions and garbage collection - perhaps the WebAssembly extensions to support them will be finished by this time. I will decide to work on either exceptions, garbage collection or additional optimisations, depending on the complexity of supporting exceptions or garbage collection.
	
	\subsection*{14 Mar - 27 Mar}
	Continue writing dissertation. Attempt to wrap up remaining unfinished features e.g. those I started in the last two weeks.
	
	\subsection*{28 Mar - 10 Apr}
	Continue with the dissertation, submitting first drafts of chapters to my supervisor. Focus on improving the code e.g. by refactoring, or implementing additional tests.
	
	\subsection*{10 Apr - 24 Apr}
	Fully focus on the dissertation, leaving the code as it is. Submit draft version of dissertation to supervisor and DoS.
	
	\subsection*{24th Apr - 8 May}
	At this point the dissertation should be complete, with only minor changes to be made over these weeks.
	\\\\
	Towards the end of these two weeks, I will submit the final version of my dissertation.
	
	
	\section*{Resource Declaration}
	I plan to do the work via remote desktop to my server located in France, so I can easily switch between using my desktop and laptop. This has 32GB RAM and two 2 TB HDDs in RAID 1 (mirrored). I will use git for version control of code and important documents, which will be regularly pushed to a private GitHub repository. In addition, both my laptop and desktop automatically download backups of data on my server at regular intervals when they are online.
	\\\\
	I accept full responsibility for this machine and I have made contingency plans to protect myself against hardware and/or software failure.
	\\\\
	I will be making use of some components of the OCaml compiler (the lexer, parser, and possibly type-checker), as well as the WebAssembly Binary Toolkit (WABT).
	
\end{document}
