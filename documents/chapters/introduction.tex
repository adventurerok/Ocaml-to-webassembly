\chapter{Introduction}

\note{The Introduction should explain the principal motivation for the project. Show how the work fits into the broad area of surrounding Computer Science and give a brief survey of previous related work. It should generally be unnecessary to quote at length from technical papers or textbooks. If a simple bibliographic reference is insufficient, consign any lengthy quotation to an appendix.}
%TODO EXPLAIN KEY MOTIVATION, IDEAS BEHIND PROJECT
My motivation for this project is to learn how to make a compiler. Compilers are essential to computing because they enable the transformation of code from high-level languages that are intuitive for use by us, into low-level machine understandable code than can actually be executed, and writing a compiler is a substantial software project that invokes many areas of computer science such as type theory and program analysis.

% TODO PREVIOUS RELATED WORK

\section{OCaml}
OCaml\cite{OCaml} is a strongly-typed functional programming language, with some imperative features such as references. I chose OCaml both as the source language of the compiler, and the language the compiler is designed in, because I wanted to gain some familiarity in writing programs in functional languages, and OCaml has similar syntax to Standard ML taught in first year, but with much better library support, and because compiling a functional programming language presents additional challenges to compiling an imperative language such as C - with first class functions and pattern matching requiring special consideration.

\section{WebAssembly}
% copied from project proposal
WebAssembly\cite{webassembly} is a stack-based binary instruction format for the web. It is not a replacement of JavaScript, instead working alongside JavaScript with the main goal of improving the performance of  more computationally intensive functions in web applications, leaving tasks like DOM manipulation to JavaScript (there are no plans for WebAssembly to support this) It  is  expected  that  a  JavaScript  application might  call  some  functions  implemented  in  WebAssembly  to  perform  computation,  and then display the results itself.
\\\\
The current MVP (minimum viable product) version of WebAssembly is designed for compiling languages like C and C++ that do not use garbage collection and can make do without exceptions. There are extensions currently being developed to add support for these features, but progress on these is slow as they often depend on other extensions, for instance the garbage collection extension depends on extensions for reference types and typed function references, which seek to expand the WebAssembly type system so for instance a garbage collector would understand the shape of data in memory\cite{Wgce}.
\\\\
WebAssembly was chosen as the target instruction set because it is relatively new, with few compilers out there currently targeting it, and it is likely to grow in popularity in the future as more extensions are added to it that make it more viable to be used - such as support for garbage collection and exceptions.

\note{TODO Alan suggests moving to Preparation, and giving an overview of WA's linguistic features. I already have a bit of an overview in the code generation section, but these are the main ones:
\begin{itemize}
	\item Stack based, structured (but compiler doesn't use this structure much / goes for unstructured options)
	\item Local variables get/set/tee
	\item No swap or dup instructions
	\item Verified i32/f32 types, must know signature of function for all function calls, blocks have a result type
	\item Can branch only out of a block early, or to the start of a loop
	\item JS interface can only pass i32 and f32 values - no strings / structs or anything
\end{itemize}}
% TODO

%TODO WHAT IS WEBASSEMBLY


% TODO DESCRIPTION OF HOW TO BUILD THE PROJECT?

\section{Related Work}
% TODO Js\_of\_ocaml, A

There have been a few attempts to compile OCaml to WebAssembly already, such as by @SanderSpies\cite{Awbfo}, who modified the existing backend of the OCaml Compiler to target WebAssembly. Their attempt worked from the `CMM' --- the final stage of the OCaml compiler before code generation, modifying that to include extra type information for WebAssembly, and then doing code generation. This differs from my approach in that I have implemented almost an entire compiler from the type-checker through to the WebAssembly code generator, but excluding lexing/parsing.
\\\\
While Sander's approach allows them to leverage the existing features and optimisations of the OCaml compiler, their approach didn't fit with my goals of learning how to write an entire compiler - such an approach wouldn't give me the freedom and opportunity to explore aspects of compiler construction such as type-checking, intermediate representations, and optimisations, which are some of the most interesting parts of the project.